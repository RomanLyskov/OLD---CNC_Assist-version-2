            //// сюда запишем текущие координаты
            //Position POS = new Position();

            //POS.A = Info.AxesA_PositionMM;
            //POS.X = Info.AxesX_PositionMM;
            //POS.Y = Info.AxesY_PositionMM;
            //POS.Z = Info.AxesZ_PositionMM;

            //DataRow dataRowLast = new DataRow(0, "");

            //dataRowLast.POS = POS;
            //dataRowLast.Machine = ExecuteCommandLastMachine;

            //DataRow dataRowNow = new DataRow(0, Gcommand);

            //DataLoader.FillStructure(dataRowLast, ref dataRowNow);

            //if (dataRowNow.Machine.SpindelON != dataRowLast.Machine.SpindelON || dataRowNow.Machine.SpeedSpindel != dataRowLast.Machine.SpeedSpindel)
            //{
            //DirectPostToController(BinaryData.pack_B5(dataRowNow.Machine.SpindelON, 2, BinaryData.TypeSignal.Hz, dataRowNow.Machine.SpeedSpindel));
            //// }

            //// if (dataRowNow.POS.X != dataRowLast.POS.X || dataRowNow.POS.Y != dataRowLast.POS.Y || dataRowNow.POS.Z != dataRowLast.POS.Z || dataRowNow.POS.Z != dataRowLast.POS.Z)
            //// {

            //// }

            //dataRowLast = dataRowNow;







        private void buttonStartTask_Click(object sender, EventArgs e)
        {

            ControllerPlanetCNC.TASK_CLEAR();

            ControllerPlanetCNC.TASK_SendStartData();

            // Определимся с границами
            _nowPos = listGkodeCommand.SelectedIndex;

            if (listGkodeCommand.SelectedItems.Count == 1)
            {
                _endPos = listGkodeCommand.Items.Count;
            }
            else
            {
                _endPos = listGkodeCommand.SelectedIndex + listGkodeCommand.SelectedItems.Count;
            }
            
            if (_nowPos >= _endPos)
            {
                return;
            }

            // При запуске передаем данные до точки, где нужно сменить инструмент, или сделать паузу
            
            bool needContinue = true;


            
            // для поиска различий при отправке данных
            //DataRow dataRowOld = new DataRow(0, "");

            while (needContinue)
            {
                DataRow dataRowNow = DataLoader.DataRows[_nowPos];

                ControllerPlanetCNC.TASK_AddCommand(dataRowNow.DataString);

                // сравним наличие изменений в данных, и проанализируем какие команды послать в контроллер

                //if (_nowPos != 0) dataRowOld = DataLoader.DataRows[_nowPos - 1];

                //// В случае наличия изменений, отправим новые данные
                //if (dataRowNow.Machine.SpindelON != dataRowOld.Machine.SpindelON || dataRowNow.Machine.SpeedSpindel != dataRowOld.Machine.SpeedSpindel)
                //{
                //    ControllerPlanetCNC.AddBinaryDataToTask(BinaryData.pack_B5(dataRowNow.Machine.SpindelON, 2, BinaryData.TypeSignal.Hz, dataRowNow.Machine.SpeedSpindel));
                //    //TODO: это нужно переделать!!!!! зафиксируем
                //    PlanetCNC_Controller.LastStatus = dataRowNow;
                //}


                //if (dataRowNow.POS.X != dataRowOld.POS.X || dataRowNow.POS.Y != dataRowOld.POS.Y || dataRowNow.POS.Z != dataRowOld.POS.Z || dataRowNow.POS.Z != dataRowOld.POS.Z)
                //{
                //    //if (Controller.INFO.NuberCompleatedInstruction == 0)
                //    //{
                //    //    //если нет номера инструкции, то отправляем пока буфер не сильно занят
                //    //    if (GlobalSetting.AppSetting.Controller == ControllerModel.PlanetCNC_MK1 && Controller.INFO.FreebuffSize < 4) return;
                //    //    if (GlobalSetting.AppSetting.Controller == ControllerModel.PlanetCNC_MK2 && Controller.INFO.FreebuffSize < 230) return;
                //    //}
                //    //else
                //    //{
                //    //    //знаем номер инструкции, и будем отправлять пока не более 10 инструкций
                //    //    if (_nowPos > (Controller.INFO.NuberCompleatedInstruction + GlobalSetting.ControllerSetting.MinBuffSize)) return;
                //    //}

                //    int speedToSend = dataRowNow.Machine.SpeedMaсhine;

                //    if (checkBoxManualSpeed.Checked)
                //    {
                //        if (dataRowNow.Machine.NumGkode == 0) speedToSend = (int)numericUpDown1.Value;

                //        if (dataRowNow.Machine.NumGkode == 1) speedToSend = (int)numericUpDown2.Value;
                //    }

                //    //координаты следующей точки
                //    float pointX = (float)dataRowNow.POS.X;
                //    float pointY = (float)dataRowNow.POS.Y;
                //    float pointZ = (float)dataRowNow.POS.Z;

                //    //добавление смещения G-кода
                //    if (ControllerPlanetCNC.CorrectionPos.UseCorrection)
                //    {
                //        //// применение пропорций
                //        //pointX *= Setting.koeffSizeX;
                //        //pointY *= Setting.koeffSizeY;

                //        //применение смещения
                //        pointX += (float)ControllerPlanetCNC.CorrectionPos.DeltaX;
                //        pointY += (float)ControllerPlanetCNC.CorrectionPos.DeltaY;

                //        //применение матрицы поверхности детали
                //        if (ControllerPlanetCNC.CorrectionPos.UseMatrix)
                //        {
                //            pointZ += ScanSurface.GetPosZ(pointX, pointY);
                //        }

                //        pointZ += (float)ControllerPlanetCNC.CorrectionPos.DeltaZ;

                //    }

                //    //отладка
                //    ControllerPlanetCNC.AddBinaryDataToTask(BinaryData.pack_B5(dataRowNow.Machine.SpindelON, 2, BinaryData.TypeSignal.Hz, dataRowNow.Machine.SpeedSpindel));


                //    ControllerPlanetCNC.AddBinaryDataToTask(BinaryData.pack_CA(ControllerPlanetCNC.Info.CalcPosPulse("X", (decimal)pointX),
                //                                                    ControllerPlanetCNC.Info.CalcPosPulse("Y", (decimal)pointY),
                //                                                    ControllerPlanetCNC.Info.CalcPosPulse("Z", (decimal)pointZ),
                //                                                    ControllerPlanetCNC.Info.CalcPosPulse("A", dataRowNow.POS.A),
                //                                                    speedToSend,
                //                                                    dataRowNow.numberRow, dataRowNow.Machine.TimeOutPause));

                //    //TODO: это нужно переделать!!!!! зафиксируем
                //    PlanetCNC_Controller.LastStatus = dataRowNow;
                //}

                _nowPos++;

                //TODO: так-же добавить прерывание, в случае смены инструмента/паузы
                
                // вариант 1 - выполняется до последней строчки
                needContinue = (_nowPos < _endPos);

                //// вариант 2 - выполняется до смены инструмента, и активируется остановка
                //if (dataRowNow.Tools.NeedChange)
                //{
                //    needContinue = false;
                //    MessageBox.Show("Возникла необходимость смены инструмента № " + dataRowNow.Tools.NumberTools +
                //                    ", с диамтром: " + dataRowNow.Tools.DiametrTools);

                //}



            }


            // данные переданы для выполнения, запустим....

            ControllerPlanetCNC.TASK_SendStopData();

            ControllerPlanetCNC.TASK_START();








            //////TODO: НУЖНО ОСТАНОВИТЬ ПЕРЕДАЧУ ДАННЫХ, если будет смена инструмента, с последующей паузой
            //////if (dataRowNow.Tools.NeedChange)
            //////{
            //////    //timerTask.Enabled = false;
            //////    //_statusTask = ETaskStatus.Pause;
            //////    //Controller.TestAllowActions = false; //разблокируем
            //////    //MessageBox.Show(@"Для дальнейшей работы, установите инструмент № " + dataRowNow.Tools.NumberTools + ", диаметром " + dataRowNow.Tools.DiametrTools + ", после установки нового инструмента, нужно продолжить выполнение (сейчас включена пауза)");
            //////    //_nowPos++;                    
            //////    //timerTask.Enabled = true;

            //////    return;
            //////}

            //////TODO: пока не работает
            //////if (dataRowNow.Extra.NeedPause)
            //////{
            //////    //MessageBox.Show(@"Выполняется пауза длительностью " + dataRowNow.Extra.timeoutMsec + @" мс.", "",
            //////    //    MessageBoxButtons.OK);
            //////    //System.Threading.Thread.Sleep(dataRowNow.Extra.timeoutMsec);
            //////}

            //////Сравнить, и установить в случае необходимости
            //////1) Шпиндель и скорость работы
            //////2) Выполнить движение с необходимой скоростью

            //////if (dataRowNow.Machine != dataRowOld.Machine)







        }







        /////////////////////* 

        ////////////////////            //pointZ = p1234.Z;



        ////////////////////             //TODO: В связи с переделкой ряда ключевых механизмов применение матрицы отключим



        ////////////////////            //1) получим координаты 4-х ближайших точек из матрицы

        ////////////////////            //текущая точка





        ////////////////////            //2) запустим математику


        ////////////////////            //Point p1 = new Point(numericUpDown11.Value, numericUpDown10.Value, numericUpDown9.Value);
        ////////////////////            //Point p2 = new Point(numericUpDown12.Value, numericUpDown14.Value, numericUpDown13.Value);
        ////////////////////            //Point p3 = new Point(numericUpDown15.Value, numericUpDown17.Value, numericUpDown16.Value);
        ////////////////////            //Point p4 = new Point(numericUpDown21.Value, numericUpDown23.Value, numericUpDown22.Value);

        ////////////////////            //Point p5 = new Point(numericUpDown18.Value, numericUpDown20.Value, numericUpDown19.Value);



        ////////////////////            //numericUpDown24.Value = p1234.X;
        ////////////////////            //numericUpDown26.Value = p1234.Y;
        ////////////////////            //numericUpDown25.Value = p1234.Z;

        ////////////////////            ////Point p01 = Geometry.GetZ(p1, p2, p3, p4, new Point(3, 3, 1));
        ////////////////////            */

        ///// <summary>
        ///// Сдвиг начальной точки
        ///// </summary>
        ///// <param name="x">новая координата</param>
        ///// <param name="y">новая координата</param>
        ///// <param name="z">новая координата</param>
        //public static void ChangeStartPosition(float x, float y, float z)
        //{
        //    _StartPosX = x;
        //    _StartPosY = y;
        //    _StartPosZ = z;
        //}

        ///// <summary>
        ///// Изменение размерности массива данных
        ///// </summary>
        ///// <param name="countX"></param>
        ///// <param name="countY"></param>
        ///// <param name="stepX"></param>
        ///// <param name="stepY"></param>
        //public static void ChangeSizeOrStep(int countX, int countY, float stepX, float stepY)
        //{

        //    //TODO:добавить возможность оставлять старые данные

        //    CountPointX = countX;
        //    CountPointY = countY;
        //    StepX = stepX;
        //    StepY = stepY;

        //    float xf = 0;
        //    float yf = 0;

        //    Matrix = new SurfacePoint[countX, countY];
        //    // заполним данными
        //    for (int y = 0; y < CountPointY; y++)
        //    {
        //        for (int x = 0; x < CountPointX; x++)
        //        {
        //            Matrix[x, y] = new SurfacePoint(StartPosX+(float)(x*stepX), StartPosY+(float) (y*stepY), StartPosZ);
        //            //dataGridView.Rows[y + 1].Cells[x + 1].Value = cScanSurface.matrix[x, y].value;
        //        }
        //    }            


        //}




/*
        /// <summary>
        /// Загрузка из файла настроек
        /// </summary>
        /// <returns></returns>
        public static void LoadSetting()
        {
            string sPulseX = LoadProperty("pulseX").Trim();
            string sPulseY = LoadProperty("pulseY").Trim();
            string sPulseZ = LoadProperty("pulseZ").Trim();
            string sStartupConnect = LoadProperty("StartupConnect").Trim();
            string sDeviceModel = LoadProperty("DeviceModel").Trim();
            string sLanguage = LoadProperty("Language").Trim();



            if (sPulseX != "") Setting.PulseX = int.Parse(sPulseX);
            if (sPulseY != "") Setting.PulseY = int.Parse(sPulseY);
            if (sPulseZ != "") Setting.PulseZ = int.Parse(sPulseZ);

            if (sStartupConnect != "") StartupConnect = bool.Parse(sStartupConnect);

            switch (sDeviceModel)
            {
                case "MK1":
                    Setting.DeviceModel = DeviceModel.MK1;
                    break;
                case "MK2":
                    Setting.DeviceModel = DeviceModel.MK2;
                    break;
                default:
                    Setting.DeviceModel = DeviceModel.Emulator;
                    break;
            }


            switch (sLanguage)
            {
                case "rus":
                    Setting.language = eLanguage.rus;
                    break;
                case "eng":
                    Setting.language = eLanguage.eng;
                    break;
                default:
                    Setting.language = eLanguage.eng;
                    break;
            }


        }


        /// <summary>
        /// Сохранение в файл настроек
        /// </summary>
        /// <returns></returns>
        public static void SaveSetting()
        {
            SaveProperty("pulseX", Setting.PulseX.ToString());
            SaveProperty("pulseY", Setting.PulseY.ToString());
            SaveProperty("pulseZ", Setting.PulseZ.ToString());
            SaveProperty("StartupConnect", StartupConnect.ToString());
            SaveProperty("DeviceModel", Setting.DeviceModel.ToString());
            SaveProperty("Language", Setting.language.ToString());
        }



        /// <summary>
        /// Функция извлечения параметра из файла настроек
        /// </summary>
        /// <param name="property">Имя параметра (строка)</param>
        /// <returns>Значение параметра (Строка), если будет отсутствовать файл настроек, или указанный параметр, то вернется ""</returns>
        private static string LoadProperty(string property)
        {
            if (!File.Exists(Filesetting)) return "";
            var sr = new StreamReader(Filesetting);
            var arr = sr.ReadToEnd().Split('\n');
            sr.Close();

            foreach (var ss in arr)
            {
                //проверим наш ли это параметр
                var posSymbol = ss.IndexOf('=');

                if (posSymbol <= 0) continue; //странный параметр, такой не нужен нам

                var sProperty = ss.Substring(0, posSymbol);
                var sValue = ss.Substring(posSymbol + 1);

                if (property.Trim() == sProperty.Trim())
                {
                    return sValue;
                }
            }
            return "";
        }


        /// <summary>
        /// Функция для сохранения параметров в файле настроек
        /// Сохраненные данные в файле будут выглядеть следующим образом:
        /// параметр = значение
        /// !!! Поэтому знак равно нельзя использовать ни в параметре ни в значении
        /// </summary>
        /// <param name="property">Имя параметра (строка)</param>
        /// <param name="value">Значение параметра (Строка)</param>
        private static void SaveProperty(string property, string value)
        {
            List<string> listProperty = new List<string>();

            // Запись параметра в файл

            // В начале получим все параметры
            if (File.Exists(Filesetting))
            {

                StreamReader sr = new StreamReader(Filesetting);
                string[] arr = sr.ReadToEnd().Split('\n');
                sr.Close();

                foreach (string ss in arr)
                {
                    // ReSharper disable once RedundantAssignment
                    var sformat = ss.Replace('\n', ' ').Trim();
                    sformat = ss.Replace('\r', ' ').Trim();

                    if (sformat.Length < 3) continue;
                    //проверим наш ли это параметр
                    int posSymbol = sformat.IndexOf('=');

                    if (posSymbol == 0) continue; //странный параметр, такой не нужен нам

                    string sProperty = sformat.Substring(0, posSymbol);
                    string sValue = sformat.Substring(posSymbol + 1);

                    if (property.Trim() == sProperty.Trim()) continue; //нужный параметр пропустим

                    listProperty.Add(sProperty + "=" + sValue);
                }
            }

            //если в существующем файле такого параметра нет, то добавим новый
            listProperty.Add(property + "=" + value);

            try
            {
                string sOut = "";

                foreach (string ss in listProperty)
                {
                    sOut += ss + Environment.NewLine;

                    //OutputFile.WriteLine(ss);
                }

                StreamWriter sw = new StreamWriter(Filesetting);
                sw.WriteLine(sOut);
                sw.Close();
            }
            catch (Exception)
            {
                //addLog(e.ToString(), true);
            }
        }





*/

//////            int numPos = 1;
//////            //TODO: а теперь из DATA заполним таблицу командами

//////            bool wrkspd = false;
//////            decimal x=0,y=0,z=0;



//////            foreach (LineCommands lcmd in GKode.kode)
//////            {
//////                int p = dataGrid.Rows.Add();

//////                dataGrid.Rows[p].Cells[0].Value = "[" + numPos.ToString().PadLeft(GKode.CountRow.ToString().Length, '0') + "]" + " " + lcmd.sGoodsCmd;
//////                dataGrid.Rows[p].Cells[1].Value = lcmd.sBadCmd;

////////*******
//////                try
//////                {
//////                    foreach (string ss in lcmd.Cmd)
//////                    {
//////                        if (ss.Trim() == "G0" || ss.Trim() == "G00") wrkspd = false;

//////                        if (ss.Trim() == "G1" || ss.Trim() == "G01") wrkspd = true;

//////                        if (ss.Substring(0, 1) == "X")
//////                        {
//////                            string value = ss.Substring(1).Trim().Replace('.', ',');
//////                            x = decimal.Parse(value);
//////                        }

//////                        if (ss.Substring(0, 1) == "Y")
//////                        {
//////                            string value = ss.Substring(1).Trim().Replace('.', ',');
//////                            y = decimal.Parse(value);
//////                        }

//////                        if (ss.Substring(0, 1) == "Z")
//////                        {
//////                            string value = ss.Substring(1).Trim().Replace('.', ',');
//////                            z = decimal.Parse(value);
//////                        }
//////                    }
//////                }
//////                catch (Exception)
//////                {
                    
//////                   // throw;
//////                }



//////                G3D.points.Add(new G3Dpoint(x, y, z, wrkspd, numPos));



//////                //******

                
//////                toolStripProgressBar.Value = numPos-1;
//////                numPos++;
//////            }


//////            toolStripProgressBar.Value = GKode.CountRow;

//////            dataGrid.Rows[0].Selected = true;
//////            //labelWorkingRow.Text = @"Выполнение будет со строки: 1";



        //private void button2_Click(object sender, EventArgs e)
        //{
        //    //TODO: создание пустой матрицы

        //    dataCode.Matrix.Clear();
        //    for (int y = 0; y < numericUpDown2.Value; y++)
        //    {
        //        matrixYline my = new matrixYline();

        //        for (int x = 0; x < numericUpDown1.Value; x++)
        //        {
        //            my.X.Add(new matrixPoint(0,0,false));
        //        }
        //        dataCode.Matrix.Add(my);
        //    }


        //    // наполнение
        //    foreach (Point pp in _pointsForScan)
        //    {
        //        dataCode.Matrix[pp.IndexY].Y = pp.Y;
        //        dataCode.Matrix[pp.IndexY].X[pp.IndexX].X = pp.X;
        //        dataCode.Matrix[pp.IndexY].X[pp.IndexX].Z = pp.Z;
        //        dataCode.Matrix[pp.IndexY].X[pp.IndexX].Used = true;
        //    }

        //}



		

            //TODO: наполнить массив данными для сканирования
            //for (int x = 0; x < numCountX.Value; x++)
            //{
            //    for (int y = 0; y < numCountY.Value; y++)
            //    {
            //        //_pointsForScan.Add(new Point(numPosX.Value + (x * numericUpDown3.Value), numPosY.Value + (y * numericUpDown3.Value), deviceInfo.AxesZ_PositionMM, x, y));

            //        dataGridView.Rows[y + 1].Cells[x + 1].Value = deviceInfo.AxesZ_PositionMM;
            //    }
            //}





            //TODO: создание пустой матрицы

            //dataCode.Matrix.Clear();
            //for (int y = 0; y < numCountY.Value; y++)
            //{
            //    matrixYline my = new matrixYline();

            //    for (int x = 0; x < numCountX.Value; x++)
            //    {
            //        my.X.Add(new matrixPoint(0, 0, false));
            //    }
            //    dataCode.Matrix.Add(my);
            //}


            // наполнение
            //foreach (Point pp in _pointsForScan)
            //{
            //    dataCode.Matrix[pp.IndexY].Y = pp.Y;
            //    dataCode.Matrix[pp.IndexY].X[pp.IndexX].X = pp.X;
            //    dataCode.Matrix[pp.IndexY].X[pp.IndexX].Z = pp.Z;
            //    dataCode.Matrix[pp.IndexY].X[pp.IndexX].Used = true;
            //}

      

	  


      //////////// Поток выполняющий сканирование
      //////////  private void theads()
      //////////  {
      //////////      if (_ctrl.ShpindelMoveSpeed != 0) return;
            
      //////////      //координаты куда передвинуться
      //////////      decimal px = dataCode.Matrix[indexScanY].X[indexScanX].X;
      //////////      decimal pz = dataCode.Matrix[indexScanY].X[indexScanX].Z;
      //////////      decimal py = dataCode.Matrix[indexScanY].Y;

      //////////      //спозиционируемся
      //////////      _ctrl.SendBinaryData(BinaryData.pack_CA(deviceInfo.CalcPosPulse("X", px), deviceInfo.CalcPosPulse("Y", py), deviceInfo.CalcPosPulse("Z", pz), (int)numSpeed.Value, 0));

      //////////      //опустим щуп
      //////////      _ctrl.SendBinaryData(BinaryData.pack_C0(0x01)); //вкл
      //////////      _ctrl.SendBinaryData(BinaryData.pack_D2((int)numSpeed.Value, (decimal)numReturn.Value));      // + настройка отхода, и скорости
      //////////      _ctrl.SendBinaryData(BinaryData.pack_C0(0x00)); //выкл






            
      //////////      //TODO: придумать как это убрать - тут подождем
      //////////      System.Threading.Thread.Sleep(1000);

      //////////      while (_ctrl.ShpindelMoveSpeed != 0)
      //////////      {
      //////////          dataCode.Matrix[indexScanY].X[indexScanX].Z = deviceInfo.AxesZ_PositionMM - numReturn.Value;
      //////////      }


      //////////      if (indexScanX == indexMaxScanX && indexScanY == indexMaxScanY)
      //////////      {
      //////////          Scan = false;
      //////////          _ctrl.SendBinaryData(BinaryData.pack_FF());
      //////////      }

      //////////      if (indexScanX < indexMaxScanX)
      //////////      {
      //////////          indexScanX++;
      //////////      }
      //////////      else
      //////////      {
      //////////          indexScanX = 0;

      //////////          if (indexScanY < indexMaxScanY)
      //////////          {
      //////////              indexScanY++;
      //////////          }
      //////////          else
      //////////          {
      //////////              indexScanY = 0;
      //////////          }
      //////////      }
      //////////  }
 


 

                //Gl.glLineStipple(1, 0x00FF); //Штриховая

            //#region Отображение инструкций из конструктора команд

            ////if (cbShowConstructor.Checked)
            ////{
            ////    foreach (object pObj in DATA_Conctructor)
            ////    {
            ////        if (pObj.GetType() == new cLine().GetType()) //проверим в данных это линия?
            ////        {
            ////            cLine line = (cLine)pObj;

            ////            Gl.glColor3f(100, 2100, 0);
            ////            Gl.glLineWidth(3);

            ////            Gl.glBegin(Gl.GL_LINES);
            ////            Gl.glVertex3d(line.pointStart.Xd, line.pointStart.Yd, line.pointStart.Zd);
            ////            Gl.glVertex3d(line.pointEnd.Xd, line.pointEnd.Yd, line.pointEnd.Zd);
            ////            Gl.glEnd();
            ////            Gl.glLineWidth(1);
            ////        }

            ////        if (pObj.GetType() == new cCircle().GetType()) //проверим в данных это линия?
            ////        {
            ////            cCircle circle = (cCircle)pObj;
            ////            //вызовем функцию, которая вернет массив точек круга
            ////            List<cLine> circleline = GetCircleToLine(circle);

            ////            Gl.glColor3f(100, 2100, 0);
            ////            Gl.glLineWidth(3);
            ////            foreach (cLine line in circleline)
            ////            {
            ////                Gl.glBegin(Gl.GL_LINES);
            ////                Gl.glVertex3d(line.pointStart.Xd, line.pointStart.Yd, line.pointStart.Zd);
            ////                Gl.glVertex3d(line.pointEnd.Xd, line.pointEnd.Yd, line.pointEnd.Zd);
            ////            }
            ////            Gl.glEnd();
            ////            Gl.glLineWidth(1);
            ////        }
            ////    }


            ////    //переделать
            ////    //foreach (TreeNode tr in treeViewCommands.Nodes[0].Nodes)
            ////    //{
            ////    //    if (tr.Name == "line")
            ////    //    {

            ////    //    }

            ////    //    if (tr.Name == "circle")
            ////    //    {
            ////    //        Gl.glColor3f(100, 2100, 0);
            ////    //        Gl.glLineWidth(3);

            ////    //        //вызовем функцию, которая вернет массив точек круга
            ////    //        List<Point3D> circlePoints = new List<Point3D>();

            ////    //        circlePoints = GetCircle(tr);

            ////    //        double tmpx = double.Parse(tr.Nodes["X1"].Text);
            ////    //        double tmpy = double.Parse(tr.Nodes["Y1"].Text);

            ////    //        foreach (Point3D pp in circlePoints)
            ////    //        {
            ////    //            Gl.glBegin(Gl.GL_LINES);
            ////    //            Gl.glVertex3d(tmpx, tmpy, 0);
            ////    //            Gl.glVertex3d(pp.X, pp.Y, 0);
            ////    //            Gl.glEnd();
            ////    //            tmpx = pp.X;
            ////    //            tmpy = pp.Y;
            ////    //        }
            ////    //        Gl.glLineWidth(1);
            ////    //    }
            ////    //}
            ////}

            //#endregion
            //#region Отображение любимых точек

            ////Gl.glColor3f(1.0F, 1.0F, 1.0F);
            ////Gl.glPointSize((float)PointsSize.Value);
            ////Gl.glBegin(Gl.GL_POINTS);

            ////foreach (cPoint poi in DATA_Points)
            ////{
            ////    Gl.glVertex3d((double)poi.X, (double)poi.Y, (double)poi.Z);
            ////}

            ////Gl.glEnd();

            ////if (cbPointShowNumbers.Checked)
            ////{
            ////    int ix = 0;
            ////    foreach (cPoint poi in DATA_Points)
            ////    {
            ////        Gl.glRasterPos3d((double)poi.X, (double)poi.Y, (double)poi.Z); //координаты расположения текста
            ////        Glut.glutBitmapString(Glut.GLUT_BITMAP_9_BY_15, ix.ToString());
            ////        ix++;
            ////    }
            ////}


            //#endregion






			//ОТЛАДКА математики
			private void button4_Click_1(object sender, EventArgs e)
			{
				Point p1 = new Point(numericUpDown11.Value, numericUpDown10.Value, numericUpDown9.Value);
				Point p2 = new Point(numericUpDown12.Value, numericUpDown14.Value, numericUpDown13.Value);
				Point p3 = new Point(numericUpDown15.Value, numericUpDown17.Value, numericUpDown16.Value);
				Point p4 = new Point(numericUpDown21.Value, numericUpDown23.Value, numericUpDown22.Value);

				Point p5 = new Point(numericUpDown18.Value, numericUpDown20.Value, numericUpDown19.Value);


				Point p12 = Geometry.CalcPX(p1, p2, p5);
				Point p34 = Geometry.CalcPX(p3, p4, p5);

				Point p1234 = Geometry.CalcPY(p12, p34, p5);

				numericUpDown24.Value = p1234.X;
				numericUpDown26.Value = p1234.Y;
				numericUpDown25.Value = p1234.Z;

				//Point p01 = Geometry.GetZ(p1, p2, p3, p4, new Point(3, 3, 1));

			}




			



///// <summary>
///// Класс для работы с G-кодом
///// </summary>
//public static class GKode
//{
//    public static List<LineCommands> kode = new List<LineCommands>();

//    public static int CountRow = 0;

//    /// <summary>
//    /// Получение текстового представления последней ошибки
//    /// </summary>
//    private static string _stringError = "";
//    /// <summary>
//    /// Получение текстового представления последней ошибки
//    /// </summary>
//    // ReSharper disable once InconsistentNaming
//    public static string stringError
//    {
//        get { return _stringError; }
//    }

//    /// <summary>
//    /// Очистка от всех данных
//    /// </summary>
//    public static void Clear()
//    {
//        kode.Clear();
//        CountRow = 0;
//    }


//    //{
//    //    //

//    //}
//    //byte[] readBuffer = new byte[64];
//    //byte[] writeBuffer = new byte[64];
//    //int bytesRead;
//    //int bytesWritten;

//    //while (IsConnect)
//    //{





//    //    //а тут мы и посылаем команды...
//    //    if (statusWorks == EStatusTheads.TaskStart)//_isWorking && !task_RUN
//    //    {
//    //        //TODO: это начало задания, поэтому в станок посылаем настройки

//    //        readBuffer = BinaryData.pack_9E(0x05);
//    //        ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //        System.Threading.Thread.Sleep(1);

//    //        readBuffer = BinaryData.pack_BF(CNC_speedNow, CNC_speedNow, CNC_speedNow);
//    //        ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //        System.Threading.Thread.Sleep(1);

//    //        readBuffer = BinaryData.pack_C0();
//    //        ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //        System.Threading.Thread.Sleep(1);
//    //        //task_RUN = true;
//    //        statusWorks = EStatusTheads.TaskWorking;
//    //    }


//    //    if (statusWorks == EStatusTheads.TaskStop)//!_isWorking && task_RUN
//    //    {
//    //        //TODO: выполнение задания завершилось, необходимо послать последние параметры в контроллер
//    //        readBuffer = BinaryData.pack_FF();
//    //        ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //        System.Threading.Thread.Sleep(1);


//    //        readBuffer = BinaryData.pack_9D();
//    //        ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //        System.Threading.Thread.Sleep(1);

//    //        readBuffer = BinaryData.pack_9E(0x02);
//    //        ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //        System.Threading.Thread.Sleep(1);

//    //        for (int i = 0; i < 7; i++)
//    //        {
//    //            readBuffer = BinaryData.pack_FF();
//    //            ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //            System.Threading.Thread.Sleep(1);
//    //        }

//    //        statusWorks = EStatusTheads.Waiting;

//    //    }

//    //    if (statusWorks == EStatusTheads.TaskWorking)
//    //    {


//    //        lineCommands lcmd = gKode.kode[_numWorkingCommand];

//    //        if (lcmd.sGoodsCmd != "")//отсеим необрабатываемые команды команды
//    //        {

//    //            foreach (string ss in lcmd.cmd)
//    //            {
//    //                if (ss == "G0") CNC_speedNow = CNC_speedG0;

//    //                if (ss == "G1") CNC_speedNow = CNC_speedG1;

//    //                if (ss.Substring(0, 1) == "X")
//    //                {
//    //                    string value = ss.Substring(1).Trim().Replace('.', ',');
//    //                    decimal posx = decimal.Parse(value);
//    //                    CNC_pulseX = (int)(posx * axesX.PulsePerMm);
//    //                }

//    //                if (ss.Substring(0, 1) == "Y")
//    //                {
//    //                    string value = ss.Substring(1).Trim().Replace('.', ',');
//    //                    decimal posy = decimal.Parse(value);
//    //                    CNC_pulseY = (int)(posy * axesY.PulsePerMm);
//    //                }

//    //                if (ss.Substring(0, 1) == "Z")
//    //                {
//    //                    string value = ss.Substring(1).Trim().Replace('.', ',');
//    //                    decimal posz = decimal.Parse(value);
//    //                    CNC_pulseZ = (int)(posz * axesZ.PulsePerMm);
//    //                }

//    //                if (ss == "M3" || ss == "M03") Spindel_ON();

//    //                if (ss == "M5" || ss == "M05") Spindel_OFF();

//    //            }
//    //        }

//    //        _numWorkingCommand++;

//    //        if (_numWorkingCommand == gKode.kode.Count) statusWorks = EStatusTheads.TaskStop;

//    //        //_numWorkingCommand
//    //        //_cmd

//    //        //todo 4 pack
//    //        readBuffer = BinaryData.pack_CA(CNC_pulseX, CNC_pulseY, CNC_pulseZ, CNC_speedNow);
//    //        ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //        System.Threading.Thread.Sleep(1);
//    //    }

//    //    // Если есть посылка массива данных 
//    //    if (arrSend)
//    //    {
//    //        if (arrIndex < ByteArrayToSend.Count)
//    //        {
//    //            readBuffer = ByteArrayToSend[arrIndex];
//    //            ec = usb_writer.Write(readBuffer, 2000, out bytesWritten);
//    //            System.Threading.Thread.Sleep(1);

//    //            arrIndex++;
//    //        }
//    //        else
//    //        {
//    //            arrSend = false;
//    //        }


//    //    }

//    //}




//}





///// <summary>
///// Класс для хранения 3D Траектории
///// </summary>
//public static class G3D
//{
//    public static List<G3Dpoint> points = new List<G3Dpoint>();




//}


///// <summary>
///// Класс для описания точки
///// </summary>
//public class G3Dpoint
//{
//    public decimal X;
//    public decimal Y;
//    public decimal Z;
//    public bool workspeed;
//    /// <summary>
//    /// Номер для сопоставления с источником комманд
//    /// </summary>
//    // ReSharper disable once NotAccessedField.Global
//    private int NumPosition = 0;


//    public G3Dpoint(decimal x, decimal y, decimal z, bool workspeed, int numPosition)
//    {
//        X = x;
//        Y = y;
//        Z = z;
//        this.workspeed = workspeed;
//        NumPosition = numPosition;
//    }
//}



   //dataRowOld = dataRowNow;

        //////if (Controller.AvailableBufferSize < 5) return; // откажемся от посылки контроллеру, пока буфер не освободиться

        //////int yy = Controller.NumberComleatedInstructions;

        ////////if (yy == 0) timerTask.Interval = 1000;
        ////////else
        ////////{
        ////////    timerTask.Interval = 100;
        ////////}

        ////////TODO: вот тут пристально нужно следить за скорость посылки 

        //////Controller.ExecuteCommand(listGkodeCommand.Items[nowPos].ToString());
     
    

        //private static void taskWorks()
        //{




        //    //TODO: добавить в параметр значение
        //   

        //    //int ttt = DataLoader.GKODS[nowPos++].indexStr;
        //    //string ss = listGkodeCommand[nowPos].ToString();

        //    Controller.ExecuteCommand(GCodeTask[nowPos++]);

        //    //nowPos++;

        //    // 1) получим строку, и отправим в контроллер
        //    //GKOD_Command gcodeNow = DataLoader.GKODS[nowPos++];




        //    ////Все необходимые команды завершены, пора всё завершить
        //    //if (Task.posCodeNow > Task.posCodeEnd)
        //    //{
        //    //    Task.StatusTask = statusVariant.Stop;
        //    //    return;
        //    //}



        //    ////TODO: добавить в параметр и это значение
        //    ////if (Task.posCodeNow > (Controller.NumberComleatedInstructions + 3)) return; // Так-же не будем много посылать команд, т.е. далеко убегать

        //    ////команда остановки G4 или M0
        //    //if (gcodeNow.needPause)
        //    //{
        //    //    if (gcodeNow.timeSeconds == 0) // M0 - команда ожидания от пользователя
        //    //    {
        //    //        _NeedPause = true;
        //    //        //Task.StatusTask = statusVariant.Paused;
        //    //        //RefreshElementsForms();
        //    //        //пауза до клика пользователя
        //    //        MessageBox.Show(@"Получена команда M0 для остановки! для дальнейшего выполнения нужно нажать на кнопку 'пауза' для дальнейшего продолжения работы.", "Пауза",
        //    //            MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
        //    //    }
        //    //    else
        //    //    {
        //    //       // toolStripStatus.Text = "Пауза " + gcodeNow.timeSeconds + " мсек. по команде G4";

        //    //        Thread.Sleep(gcodeNow.timeSeconds); // пауза в мсек.

        //    //        //toolStripStatus.Text = "";
        //    //    }
        //    //}

        //    ////команда смены инструмента
        //    //if (gcodeNow.changeInstrument)
        //    //{
        //    //    _NeedPause = true;
        //    //    //Task.StatusTask = statusVariant.Paused;
        //    //    //RefreshElementsForms();

        //    //    //пауза до клика пользователя
        //    //    MessageBox.Show(@"Активирована ПАУЗА! Установите инструмент №:" + gcodeNow.numberInstrument + " имеющий диаметр: " + gcodeNow.diametr + " мм. и нажмите кнопку 'пауза' для продолжения сверления", "Пауза",
        //    //        MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
        //    //}





        //    //double pointX = (double)gcodeNow.X;
        //    //double pointY = (double)gcodeNow.Y;
        //    //double pointZ = (double)gcodeNow.Z;

        //    ////добавление смещения G-кода
        //    //if (Setting.CorrectGKode)
        //    //{
        //    //    // применение пропорций
        //    //    pointX *= Setting.koeffSizeX;
        //    //    pointY *= Setting.koeffSizeY;

        //    //    //применение смещения
        //    //    pointX += Setting.deltaX;
        //    //    pointY += Setting.deltaY;
        //    //    pointZ += Setting.deltaZ;

        //    //    //применение матрицы поверхности детали
        //    //    if (Setting.deltaFeed)
        //    //    {
        //    //        pointZ += GetDeltaZ(pointX, pointY);
        //    //    }
        //    //}

        //    //int posX = Controller.INFO.CalcPosPulse("X", (decimal)pointX);
        //    //int posY = Controller.INFO.CalcPosPulse("Y", (decimal)pointY);
        //    //int posZ = Controller.INFO.CalcPosPulse("Z", (decimal)pointZ);

        //    //TODO: доделать управление скоростью ручая/по программе
        //    //int speed = (gcodeNow.workspeed) ? UserSpeedG1 : UserSpeedG0;
        //    //int speed = 500;


        //    //if (checkBoxNewSpped.Checked)
        //    //{
        //    //    // новый алгоритм
        //    //    Controller.SendBinaryData(BinaryData.pack_CA(posX, posY, posZ, 0, speed, Task.posCodeNow,
        //    //        gcodeNow.angleVectors, gcodeNow.Distance, (int)numericUpDown9.Value));
        //    //}
        //    //else
        //    //{
        //    //    //старый алгоритм
        //    // Controller.SendBinaryData(BinaryData.pack_CA(posX, posY, posZ, 0, speed, Task.posCodeNow, 0, 0));
        //    //}

        //    //Task.posCodeNow++;
        //    //textBoxNumberLine.Text = deviceInfo.NuberCompleatedInstruction.ToString();
        //    ////textBoxNumberLine.Text = Task.posCodeNow.ToString();
        //}




        //private static double GetDeltaZ(double _x, double _y)
        //{
        //    //точка которую нужно отобразить
        //    dobPoint pResult = new dobPoint(_x, _y, 0, 0);


        //    int indexXmin = 0;
        //    int indexYmin = 0;
        //    for (int x = 0; x < dataCode.matrix2.GetLength(0) - 1; x++)
        //    {
        //        for (int y = 0; y < dataCode.matrix2.GetLength(1) - 1; y++)
        //        {
        //            if (_x > dataCode.matrix2[x, 0].X && _x < dataCode.matrix2[x + 1, 0].X && dataCode.matrix2[0, y].Y < _y && dataCode.matrix2[0, y + 1].Y > _y)
        //            {
        //                indexXmin = x;
        //                indexYmin = y;
        //            }
        //        }
        //    }


        //    dobPoint p1 = new dobPoint(dataCode.matrix2[indexXmin, indexYmin].X, dataCode.matrix2[indexXmin, indexYmin].Y, dataCode.matrix2[indexXmin, indexYmin].Z, 0);
        //    dobPoint p3 = new dobPoint(dataCode.matrix2[indexXmin, indexYmin + 1].X, dataCode.matrix2[indexXmin, indexYmin + 1].Y, dataCode.matrix2[indexXmin, indexYmin + 1].Z, 0);
        //    dobPoint p2 = new dobPoint(dataCode.matrix2[indexXmin + 1, indexYmin].X, dataCode.matrix2[indexXmin + 1, indexYmin].Y, dataCode.matrix2[indexXmin + 1, indexYmin].Z, 0);
        //    dobPoint p4 = new dobPoint(dataCode.matrix2[indexXmin + 1, indexYmin + 1].X, dataCode.matrix2[indexXmin + 1, indexYmin + 1].Y, dataCode.matrix2[indexXmin + 1, indexYmin + 1].Z, 0);

        //    dobPoint p12 = Geometry.CalcPX(p1, p2, pResult);
        //    dobPoint p34 = Geometry.CalcPX(p3, p4, pResult);
        //    dobPoint p1234 = Geometry.CalcPY(p12, p34, pResult);
        //    /* 

        //                //pointZ = p1234.Z;



        //                 //TODO: В связи с переделкой ряда ключевых механизмов применение матрицы отключим



        //                //1) получим координаты 4-х ближайших точек из матрицы

        //                //текущая точка
                    




        //                //2) запустим математику


        //                //Point p1 = new Point(numericUpDown11.Value, numericUpDown10.Value, numericUpDown9.Value);
        //                //Point p2 = new Point(numericUpDown12.Value, numericUpDown14.Value, numericUpDown13.Value);
        //                //Point p3 = new Point(numericUpDown15.Value, numericUpDown17.Value, numericUpDown16.Value);
        //                //Point p4 = new Point(numericUpDown21.Value, numericUpDown23.Value, numericUpDown22.Value);

        //                //Point p5 = new Point(numericUpDown18.Value, numericUpDown20.Value, numericUpDown19.Value);



        //                //numericUpDown24.Value = p1234.X;
        //                //numericUpDown26.Value = p1234.Y;
        //                //numericUpDown25.Value = p1234.Z;

        //                ////Point p01 = Geometry.GetZ(p1, p2, p3, p4, new Point(3, 3, 1));
        //                */

        //    return p1234.Z;
        //}







            //if (Task.StatusTask == statusVariant.Waiting) return;
            //Task.StatusTask = statusVariant.Stop;



//if (Task.StatusTask == statusVariant.Starting) return; //пока задание не запустилось, нет смысла ставить паузу

//if (Task.StatusTask == statusVariant.Working || Task.StatusTask == statusVariant.Paused)
//{
//    Task.StatusTask = (Task.StatusTask == statusVariant.Paused) ? statusVariant.Working : statusVariant.Paused;
//}



//if (TaskTimer.Enabled) return; //нельзя дальше, если таймер включен

//if (!Controller.Connected)
//{
//    MessageBox.Show(@"Нет связи с контроллером!");
//    return;
//}

//if (GKODS.Count == 0)
//{
//    // нет данных для выполнения
//    MessageBox.Show(@"Нет данных для выполнения!");
//    return;
//}

////если в списке команд не выбрана строчка, то спозиционируемся на первой
//if (listGkodeCommand.SelectedIndex == -1) listGkodeCommand.SelectedIndex = 0;

//if (listGkodeCommand.SelectedItems.Count == 1)   //выбрана всего одна строка, а значит для выполнения будет указан диапазон, от этой строки и до конца
//{
//    DialogResult dlgres = MessageBox.Show(@"Запустить выполнение G-кода со строки №: " + (listGkodeCommand.SelectedIndex + 1).ToString()
//        + "\n и до последней?", @"Запуск выполнения программы", MessageBoxButtons.OKCancel, MessageBoxIcon.Information);

//    if (dlgres == DialogResult.Cancel) return;

//    //установим границы выполнения
//    Task.posCodeStart = listGkodeCommand.SelectedIndex;
//    Task.posCodeEnd = listGkodeCommand.Items.Count;
//    Task.posCodeNow = Task.posCodeStart;
//}
//else   //выбран диапазон строк
//{
//    DialogResult dlgr = MessageBox.Show(@"Запустить выполнение G-кода со строки №: " + (listGkodeCommand.SelectedIndex + 1).ToString()
//        + @" по строку №: " + (listGkodeCommand.SelectedIndex + listGkodeCommand.SelectedItems.Count).ToString()
//        + "?", @"Запуск выполнения программы", MessageBoxButtons.OKCancel, MessageBoxIcon.Information);

//    if (dlgr == DialogResult.Cancel) return;

//    //установим границы выполнения
//    Task.posCodeStart = listGkodeCommand.SelectedIndex;
//    Task.posCodeEnd = listGkodeCommand.SelectedIndex + listGkodeCommand.SelectedItems.Count;
//    Task.posCodeNow = Task.posCodeStart;
//}


//if (panelManualControl != null) panelManualControl.checkBoxManualMove.Checked = false; // отключим реакцию на нажатие NUM-pad

//Task.StatusTask = statusVariant.Starting;
//TaskTimer.Enabled = true;


//public void RefreshControl()
//{
//    //this.Enabled = Controller.Connected;

//    //groupBoxWorking.Enabled = Controller.Connected;
//    //groupBoxManualSpeedGkode.Enabled = Controller.Connected;

//    //// Кнопки запуска остановки заданий
//    //groupBoxWorking.Enabled = Controller.Connected;

//    //if (Controller.Connected)
//    //{
//    //    if (TimerRefresh.Enabled)
//    //    {
//    //        buttonStartTask.Enabled = false;

//    //        if (Task.StatusTask == statusVariant.Paused)
//    //        {
//    //            btStopTask.Enabled = false;
//    //            buttonPauseTask.Enabled = true;
//    //        }
//    //        else
//    //        {
//    //            btStopTask.Enabled = true;
//    //            buttonPauseTask.Enabled = true;
//    //        }
//    //    }
//    //    else //таймер выполнения задания выключен
//    //    {
//    //        buttonStartTask.Enabled = true;
//    //        btStopTask.Enabled = false;
//    //        buttonPauseTask.Enabled = false;
//    //    }





//    //}


//}

//listGkodeCommand.DataSource = DataCode.Data_string;



//if (!Controller.Connected)
//{
//    TaskTimer.Enabled = false;
//    return;
//}

//// скорость с главной формы
//int UserSpeedG1 = (int)numericUpDown1.Value;
//int UserSpeedG0 = (int)numericUpDown2.Value;

//GKOD_Command gcodeNow = null;

//if (Task.posCodeNow == GKODS.Count)
//{
//    //уже дошли до конца
//    if (Task.StatusTask == statusVariant.Working)
//    {
//        Task.StatusTask = statusVariant.Stop;
//    }
//}
//else
//{
//    gcodeNow = GKODS[Task.posCodeNow];
//}





///// <summary>
///// Выполнение g-кода
///// </summary>
///// <param name="dataList"></param>
//public static void Planet_Execute(string value)
//{
//    Planet_ParseStringCode(value);

//    //действия комманд TODO: потом перевести это в параметры, для возможности настройки
//    // M3 - включить канал 1 (шпиндель)
//    // M5 - выключить канал 1
//    // M7 - включить канал 2 (сож1)
//    // M8 - включить канал 3 (сож2)
//    // M9 - выключить канал 2 и 3

//}



//private static void Planet_ParseStringCode(string value)
//{
//    //получим символ разделения дробной и целой части.
//    string symbSeparatorDec = CultureInfo.CurrentCulture.NumberFormat.CurrencyDecimalSeparator.ToString();
//    ////            //string symbSeparatorGroup = CultureInfo.CurrentCulture.NumberFormat.CurrencyGroupSeparator.ToString(); 

//    char Csourse = '.';
//    char Cdestination = ',';

//    if (symbSeparatorDec == ".")
//    {
//        Csourse = ',';
//        Cdestination = '.';
//    }


//    //GKOD_resultParse result;

//    // 1) распарсим строку
//    List<string> lcmd = Planet_parserGkodeLine(value.ToUpper());

//    if (lcmd.Count == 0) return;

//    bool needMove = false; //если в перечне комманд встретилась команда X,Y,Z,A то необходимо выполнить движение, но только после перебора всей строки

//    foreach (string CODE in lcmd)
//    {
//        if (CODE == "M3")
//        {
//            PlanetCNC_Controller.Spindel_ON();
//        }

//        if (CODE == "M5")
//        {
//            PlanetCNC_Controller.Spindel_OFF();
//        }

//        if (CODE == "M7")
//        {
//            PlanetCNC_Controller.Chanel2 = true;
//        }

//        if (CODE == "M8")
//        {
//            PlanetCNC_Controller.Chanel3 = true;
//        }

//        if (CODE == "M9")
//        {
//            PlanetCNC_Controller.Chanel2 = false;
//            PlanetCNC_Controller.Chanel3 = false;
//        }


//        if (CODE == "G0")
//        {
//            PlanetCNC_Controller.lastG0 = true;
//            PlanetCNC_Controller.lastG1 = false;
//            PlanetCNC_Controller.lastG2 = false;
//            PlanetCNC_Controller.lastG3 = false;
//        }

//        if (CODE == "G1")
//        {
//            PlanetCNC_Controller.lastG0 = false;
//            PlanetCNC_Controller.lastG1 = true;
//            PlanetCNC_Controller.lastG2 = false;
//            PlanetCNC_Controller.lastG3 = false;
//        }

//        if (CODE == "G2")
//        {
//            PlanetCNC_Controller.lastG0 = false;
//            PlanetCNC_Controller.lastG1 = false;
//            PlanetCNC_Controller.lastG2 = true;
//            PlanetCNC_Controller.lastG3 = false;
//        }

//        if (CODE == "G3")
//        {
//            PlanetCNC_Controller.lastG0 = false;
//            PlanetCNC_Controller.lastG1 = false;
//            PlanetCNC_Controller.lastG2 = false;
//            PlanetCNC_Controller.lastG3 = true;
//        }

//        if (CODE.Substring(0, 1) == "F") //скорость движения, извлечем
//        {
//            string svalue = CODE.Substring(1).Replace(Csourse, Cdestination); ;
//            int spd = 0;
//            int.TryParse(svalue, out spd);

//            if (PlanetCNC_Controller.lastG0) PlanetCNC_Controller.lastG0speed = spd;
//            if (PlanetCNC_Controller.lastG1) PlanetCNC_Controller.lastG1speed = spd;
//            if (PlanetCNC_Controller.lastG2) PlanetCNC_Controller.lastG2speed = spd;
//            if (PlanetCNC_Controller.lastG3) PlanetCNC_Controller.lastG3speed = spd;

//        }

//        if (CODE.Substring(0, 1) == "N") //номер кадра
//        {
//            string svalue = CODE.Substring(1).Replace(Csourse, Cdestination); ;
//            int numKadr = 0;
//            int.TryParse(svalue, out numKadr);

//            PlanetCNC_Controller.numKadr = numKadr;
//        }

//        if (CODE.Substring(0, 1) == "S") //скорость движения, извлечем
//        {
//            string svalue = CODE.Substring(1).Replace(Csourse, Cdestination); ;
//            int spd = 0;
//            int.TryParse(svalue, out spd);

//            PlanetCNC_Controller.ValueHz = spd;

//            Controller.SendBinaryData(BinaryData.pack_B5(PlanetCNC_Controller.lastChanel1ON, 2, BinaryData.TypeSignal.Hz, PlanetCNC_Controller.ValueHz));
//        }


//        if (CODE.Substring(0, 1) == "X") //координата
//        {
//            string svalue = CODE.Substring(1).Replace(Csourse, Cdestination); ;
//            double pos = 0;
//            double.TryParse(svalue, out pos);



//            if (PlanetCNC_Controller.AbsolutlyPos) PlanetCNC_Controller.lastPosXpulse = (int)(pos * GlobalSetting.controllerSetting.AxleX.countPulse);
//            else PlanetCNC_Controller.lastPosXpulse += (int)(pos * GlobalSetting.controllerSetting.AxleX.countPulse);

//            needMove = true;
//        }


//        if (CODE.Substring(0, 1) == "Y") //координата
//        {
//            string svalue = CODE.Substring(1).Replace(Csourse, Cdestination); ;
//            double pos = 0;
//            double.TryParse(svalue, out pos);



//            if (PlanetCNC_Controller.AbsolutlyPos) PlanetCNC_Controller.lastPosYpulse = (int)(pos * GlobalSetting.controllerSetting.AxleY.countPulse);
//            else PlanetCNC_Controller.lastPosYpulse += (int)(pos * GlobalSetting.controllerSetting.AxleY.countPulse);

//            needMove = true;
//        }


//        if (CODE.Substring(0, 1) == "Z") //координата
//        {
//            string svalue = CODE.Substring(1).Replace(Csourse, Cdestination); ;
//            double pos = 0;
//            double.TryParse(svalue, out pos);



//            if (PlanetCNC_Controller.AbsolutlyPos) PlanetCNC_Controller.lastPosZpulse = (int)(pos * GlobalSetting.controllerSetting.AxleZ.countPulse);
//            else PlanetCNC_Controller.lastPosZpulse += (int)(pos * GlobalSetting.controllerSetting.AxleZ.countPulse);

//            needMove = true;
//        }


//        if (CODE.Substring(0, 1) == "A") //координата
//        {
//            string svalue = CODE.Substring(1);
//            double pos = 0;
//            double.TryParse(svalue, out pos);



//            if (PlanetCNC_Controller.AbsolutlyPos) PlanetCNC_Controller.lastPosApulse = (int)(pos * GlobalSetting.controllerSetting.AxleA.countPulse);
//            else PlanetCNC_Controller.lastPosApulse += (int)(pos * GlobalSetting.controllerSetting.AxleA.countPulse);

//            needMove = true;
//        }




//        if (CODE == "G90")
//        {
//            PlanetCNC_Controller.AbsolutlyPos = true; //применяем абсолютные координаты
//        }

//        if (CODE == "G91")
//        {
//            PlanetCNC_Controller.AbsolutlyPos = false;//применяем относительные координаты
//        }


//    }//foreach (string CODE in lcmd)

//    if (needMove)
//    {

//        //TODO: посылаем команду движения
//        //double pointX = (double)gcodeNow.X;
//        //double pointY = (double)gcodeNow.Y;
//        //double pointZ = (double)gcodeNow.Z;

//        ////добавление смещения G-кода
//        //if (Setting.CorrectGKode)
//        //{
//        //    // применение пропорций
//        //    pointX *= Setting.koeffSizeX;
//        //    pointY *= Setting.koeffSizeY;

//        //    //применение смещения
//        //    pointX += Setting.deltaX;
//        //    pointY += Setting.deltaY;
//        //    pointZ += Setting.deltaZ;

//        //    //применение матрицы поверхности детали
//        //    if (Setting.deltaFeed)
//        //    {
//        //        pointZ += GetDeltaZ(pointX, pointY);
//        //    }
//        //}

//        int speed = 100; //если вдруг не была задана скорость, т.к. ноль посылать нельзя

//        if (PlanetCNC_Controller.lastG0) speed = PlanetCNC_Controller.lastG0speed;
//        if (PlanetCNC_Controller.lastG1) speed = PlanetCNC_Controller.lastG1speed;
//        if (PlanetCNC_Controller.lastG2) speed = PlanetCNC_Controller.lastG2speed;
//        if (PlanetCNC_Controller.lastG3) speed = PlanetCNC_Controller.lastG3speed;

//        Controller.SendBinaryData(BinaryData.pack_CA(PlanetCNC_Controller.lastPosXpulse, PlanetCNC_Controller.lastPosYpulse, PlanetCNC_Controller.lastPosZpulse, PlanetCNC_Controller.lastPosApulse, speed, PlanetCNC_Controller.numKadr));
//    }

//    //string sGoodsCmd = "";
//    //string sBadCmd = "";

//    //// 2) проанализируем список команд, и разберем команды на те которые знаем и не знаем
//    //for (int i = 0; i < lcmd.Count; i++)
//    //{
//    //    string sCommd = lcmd[i].Substring(0, 1).Trim().ToUpper();
//    //    string sValue = lcmd[i].Substring(1).Trim().ToUpper();

//    //    bool good = false;

//    //    if (sCommd == "G")
//    //    {
//    //        //скорости движения
//    //        if (sValue == "0" || sValue == "00") good = true;
//    //        if (sValue == "1" || sValue == "01") good = true;
//    //        // пауза в работе
//    //        if (sValue == "4" || sValue == "04")
//    //        {
//    //            if ((i + 1) < lcmd.Count)
//    //            {
//    //                //проверим что есть ещё параметр "P"
//    //                if (lcmd[i + 1].Substring(0, 1).ToUpper() == "P")
//    //                {
//    //                    sGoodsCmd += lcmd[i].Trim().ToUpper() + " " + lcmd[i + 1].Trim().ToUpper();
//    //                    continue;
//    //                }
//    //            }
//    //        }
//    //    }

//    //    if (sCommd == "M")
//    //    {
//    //        //остановка до нажатия кнопки продолжить
//    //        if (sValue == "0" || sValue == "00") good = true;
//    //        //вкл/выкл шпинделя
//    //        if (sValue == "3" || sValue == "03") good = true;
//    //        if (sValue == "5" || sValue == "05") good = true;
//    //        //смена инструмента
//    //        if (sValue == "6" || sValue == "06")
//    //        {
//    //            if ((i + 2) < lcmd.Count)
//    //            {
//    //                //проверим что есть ещё параметр "T" и "D"
//    //                if (lcmd[i + 1].Substring(0, 1).ToUpper() == "T" && lcmd[i + 2].Substring(0, 1).ToUpper() == "D")
//    //                {
//    //                    sGoodsCmd += lcmd[i].Trim().ToUpper() + " " + lcmd[i + 1].Trim().ToUpper() + " " + lcmd[i + 2].Trim().ToUpper();
//    //                    continue;
//    //                }
//    //            }
//    //        }
//    //    }

//    //    if (sCommd == "X" || sCommd == "Y" || sCommd == "Z")
//    //    {
//    //        //координаты 3-х осей 
//    //        good = true;
//    //    }

//    //    if (good)
//    //    {
//    //        sGoodsCmd += lcmd[i] + " ";
//    //    }
//    //    else
//    //    {
//    //        sBadCmd += lcmd[i] + " ";
//    //    }
//    //} //for (int i = 0; i < lcmd.Count; i++)


//    //if (lcmd.Count == 0) sBadCmd = value;

//    //result = new GKOD_resultParse(value, sGoodsCmd, sBadCmd);

//    // return result;
//}


//private static List<string> Planet_parserGkodeLine(string value)
//{

//    List<string> lcmd = new List<string>();

//    if (value.Trim() == "") return lcmd;

//    // если строка начинается со скобки, то эту строку не анализируем, т.к. это комментарий!!!
//    if (value.Substring(0, 1) == "(")
//    {
//        lcmd.Add(value);
//        return lcmd;
//    }

//    if (value.Substring(0, 1) == "%") //тоже пропускаем эту сторку
//    {
//        lcmd.Add(value);
//        return lcmd;
//    }

//    int inx = 0;

//    bool collectCommand = false;

//    foreach (char symb in value)
//    {
//        if (symb > 0x40 && symb < 0x5B)  //символы от A до Z
//        {
//            if (collectCommand)
//            {
//                inx++;
//            }

//            collectCommand = true;
//            lcmd.Add("");
//        }

//        if (collectCommand && symb != ' ') lcmd[inx] += symb.ToString();
//    }

//    return lcmd;
//}


